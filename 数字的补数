题目： 给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

这个题有两个问题需要解决:

怎么对一个二进制的一位取反?
怎么定位出最高位的1的位置?
位操作里经常用到的一个东西叫mask, 当你需要对二进制数的一部分区域进行操作(取反或者set 1或者set 0)的时候, 构建一个mask来帮助你处理是非常简单的. 举个例子, 比如你需要对一个二进制数的末尾3位 set 0, 一个bit要set 0, 只需要& 0 即可, 但是你只想对末尾3位 set 0, 那么这意味着你需要保留其余的位, 对这个二进制数 & 11111...000, 就可以满足这个操作, 11111...000这个数, 就是所谓的mask.

对一个二进制的一位取反, 我们可以使用 ^ 1的操作做到这一点, 那么怎么构建一个不包含前导0的mask来做取反操作呢? 我们可以这样:

while (mask < num) { //只要mask不大于num, 那么这就意味着我们还没到前导0结束的位置. 
    mask = 1 | (mask << 1);
}

Code:

int findComplement(int num){
    int i = 0;
    int mask = 0;

    while (mask < num) {
        mask = 1 | (mask << 1);
    }
    
    return num ^ mask;
}
